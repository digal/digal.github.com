<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios | Лошоть и байты]]></title>
  <link href="http://digal.github.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://digal.github.com/"/>
  <updated>2012-06-07T15:13:32+04:00</updated>
  <id>http://digal.github.com/</id>
  <author>
    <name><![CDATA[Yuri Buyanov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Cocoapods: управление зависимостями в iOS-проектах]]></title>
    <link href="http://digal.github.com/blog/2012/06/06/cocoapods/"/>
    <updated>2012-06-06T21:52:00+04:00</updated>
    <id>http://digal.github.com/blog/2012/06/06/cocoapods</id>
    <content type="html"><![CDATA[<p>Собрался завтра рассказать коллегам про управление зависимостями в iOS-проектах и решил, что написать пост — самый лучший способ подготовиться и привести мысли в порядок. Надеюсь, этот "побочный продукт" поможет и кому-то из читателей.</p>

<!--more-->


<h2>Проблемы?</h2>

<p>Наверное, каждый, кто добавлял в iOS- (или, если брать шире, Cocoa-) проект библиотеку-другую, знает, насколько бесчеловечно организована работа со сторонним кодом в XCode и всём эппловском тулчейне. Особенно очевидна проблема для тех, кто ранее разрабатывал под платформы, где есть развитые средства для управления зависимостями. В частности это Java (и всё разношёрстное JVM-based-племя) c монстрообразным Maven и инструментами на его основе (ivy, gradle, buildr, sbt) и Ruby (с общепринятыми gems и bundler). Собственно, так было и в моём случае. Попробую описать вкратце встречающиеся проблемы.</p>

<h3>Установка</h3>

<p>Начинается всё с установки. Инструкция по оной к более-менее развесистой библиотеке занимает обычно не один экран текста со скриншотами, да ещё и имеет неприятное свойство устаревать или быть несовместимой с какими-то версиями XCode. Хорошими примерами могут быть <a href="https://github.com/RestKit/RestKit/wiki/Installing-RestKit-in-Xcode-4.x">RestKit</a> или, например, <a href="http://sqlcipher.net/ios-tutorial">SQLCipher</a>. Да и если библиотека устанавливается просто добавлением исходников (или статической либы) в проект, процедура скачать-распаковать-перенести-добавить-в-проект начинает несколько доставать. И уж совершенно точно это всё отбивает охоту попробовать несколько библиотек, с тем, чтобы найти подходящую под нужды конкретного проекта.</p>

<h3>Хранение</h3>

<p>После установки, перед разработчиком встаёт выбор варианта хранения.</p>

<ul>
<li>Положить статически собранную библиотеку в проект и VCS.</li>
<li>Положить сорцы библиотеки в проект и VCS. Обычно в какую-нибудь отдельную папочку типа Vendors.</li>
<li>Положить сорцы в виде Git-сабмодуля.</li>
<li>Держать библиотеки вообще вне VCS.</li>
<li>Вытаскивать библиотеки откуда-либо шелл-скриптом при сборке.</li>
</ul>


<p>У каждого из этих способов есть куча разных достоинств и надостатков. Даже ставшие стандартом де-факто git submodules неидеальны. Библиотека-то может лежать и в SVN. А уж сколько плясок с бубном придётся выполнить, чтобы сменить репозиторий (например, на свой форк библиотеки). Впрочем, на первых порах проблемы вызывает даже процесс обновления исходников.</p>

<h3>Подзависимости</h3>

<p>Иногда наши библиотеки используют "ещё более другие"© библиотеки. Чаще всего, они лежат вместе с исходниками родительской библиотеки. Весёлости начинаются тогда, когда в вашем проекте, или в другой библиотеке эта дочерняя библиотека уже используется. А если она ещё и другой версии? В этом случае приходится выбирать, от какой от них избавиться.</p>

<h3>Обновление</h3>

<p>Вот где начинается главное веселье. Проблемы могут возникнуть уже при попытке определить, а какая, собственно, версия используется сейчас. Хорошо если это сабмодуль, или есть какой-ниубдь README. А если нет? Проблема вовсе не надумана: невозможность узнать текущую версию библиотеки мешает понять, например, исправлен ли в ней определённый баг.</p>

<p>Дальше — интереснее. Хорошим примером тут будет всё тот же RestKit. Обновление с версии 0.9.4 до 0.10.0 с непривычки может легко съесть рабочий день. Тут и пляски с сабмодулем, и обновление Header Search Paths (которые, кстати, теперь, оказываются в разных местах при сборке из XCode и на билд-сервере). По сути, обновление библиотеки, это просто ещё одна установка. Как-то спасают здесь (не всегда) только git submodules.</p>

<h2>Решение</h2>

<p>Итак, как мы выяснили, проблем при использовании библиотек в Cocoa-разработке возникает целая куча. При этом на других платформах она вполне себе решается использованием dependency management tools, таких как maven или bundler. Как оказалось, альтернатив для платформы от Apple, оказалось даже несколько, однако стандартом де-факто сегодня становится одна: <a href="http://cocoapods.org/">CocoaPods</a>. Этот инструмент создан бывшим Ruby-девелопером Eloy Durán, написан на Ruby, и очень напоминает bundler.</p>

<h3>Установка</h3>

<p>Cocoapods является рубёвым гемом, поэтому установка проста до безобразия:</p>

<p>```</p>

<pre><code>$ [sudo] gem install cocoapods
$ pod setup
</code></pre>

<p>```</p>

<p>Собственно всё, теперь cocoapods установлен на вашей машине.</p>

<h3>Podfile</h3>

<p>Все зависимости прописываются в специальном файле под названием <code>Podfile</code>. Синтаксис довольно простой. Предположим, мы хотим добавить в наш проект (<code>Example.xcodeproj</code>) библиотеку <code>AFNetworking</code>. Создаём в папке с проектом (рядом с .xcodeproj) оный подфайл и пишем туда:</p>

<p>``` ruby</p>

<pre><code>platform :ios

dependency 'AFNetworking', '&gt;= 0.9.1'
</code></pre>

<p>```</p>

<p>затем делаем:</p>

<p>```</p>

<pre><code>$ pod install Example.xcodeproj
</code></pre>

<p>```</p>

<p>и вуаля:</p>

<p>```</p>

<pre><code>Updating spec repo `master'
Installing AFNetworking (0.9.1)
Generating support files

[!] From now on use 'Example.xcworkspace' instead of 'Example.xcodeproj'.
</code></pre>

<p>```</p>

<p>Последняя строчка говорит нам о том, что cocoapods создал workspace с таким же названием, как и наш проект, и теперь надо использовать именно его. Собственно, вот как выглядит папка с проектом после установки подов:</p>

<p>```</p>

<pre><code>$ tree -L 1
.
├── Default.png
├── Default@2x.png
├── Example
├── Example.xcodeproj 
├── Example.xcworkspace 
├── Pods
├── Podfile
└── Podfile.lock
</code></pre>

<p>```</p>

<p>Этот воркспейс состоит из нашего проекта и проекта Pods, содержащего все указанные в подфайле библиотеки с зависимостями и собирающегося в одну единственную библиотеку <code>libPods.a</code>. Собственно, это всё. Никаких копирований-распаковок, никаких ковыряний в build settings. Собcтвенно и хранить-то папочку с проектом Pods в VCS не нужно, достаточно добавить только Podfile и Example.xcworkspace (и то я не уверен, что второе обязательно).</p>

<h3>Specs</h3>

<p>Естественно, никакой магии в этом нет, вся информация о зависимостях (откуда тянуть файлы, какие есть подзависимости, нужен ли для сборки ARC, какие платформы поддерживаются) содержится в большом <a href="https://github.com/cocoapods/specs">репозитории</a> на гитхабе в виде файликов, называющихся Specs. Искать по нему библиотеки можно с помощью команды <code>pod search</code>, или на <a href="http://cocoapods.org">сайте проекта</a>, а присоединиться к команде мейнтейнеров может любой: достаточно написать свою спеку (это довольно просто) и сделать pull request, что собственно я и сделал.</p>

<p>Кстати, слежение за пулл-реквестами в specs-репозиторий, равно как и слежение за <a href="http://twitter.com/CocoaPodsOrg">твиттером проекта</a> — хороший способ находить полезные библиотеки, чем я и пользуюсь для своих линкопостов.</p>

<h3>Версии и обновление</h3>

<p>Cocoapods использует <a href="http://semver.org/">semantic versioning</a> для зависимостей, поэтому их версии можно указывать несколькими способами. Здесь, в принципе, почти всё понятно из синтаксиса.</p>

<ul>
<li><code>&gt; 0.1</code></li>
<li><code>&gt;= 0.1</code></li>
<li><code>&lt; 0.1</code></li>
<li><code>&lt;= 0.1</code></li>
<li><code>~&gt; 0.1.2</code> - использовать версии от 0.1.2 до 0.2 (не включая последнюю).</li>
</ul>


<p>Можно, кстати, и не указывать версию, в этом случае всегда будет использоваться самая последняя.</p>

<p>Чтобы обновить библиотеку (или добавить ещё одну), достаточно просто обновить Podfile и опять сделать <code>pod install</code></p>

<h3>Посторонние библиотеки</h3>

<p>Всё это прекрасно — скажете вы — но что делать, если нужной мне библиотеки нет в спеках, а заморачиваться с пулл-реквестом лень? Здесь есть несколько способов. Во-первых, можно использовать спеку, не лежащую в главном репозитории:</p>

<p>``` ruby</p>

<pre><code>dependency 'JSONKit', :podspec =&gt; 'https://raw.github.com/gist/1346394/1d26570f68ca27377a27430c65841a0880395d72/JSONKit.podspec'
</code></pre>

<p>```</p>

<p>Во-вторых, можно даже включить спеку прямо в подфайл:</p>

<p>``` ruby</p>

<pre><code>dependency do |spec|
  spec.name         = 'JSONKit'
  spec.version      = '1.4'
  spec.source       = { :git =&gt; 'https://github.com/johnezang/JSONKit.git', :tag =&gt; 'v1.4' }
  spec.source_files = 'JSONKit.*'
end
</code></pre>

<p>```</p>

<p>В-третьих, если спека на библиотеку уже есть, но вы хотите использовать другую (более новую, например, версию), можно указать репозиторий, откуда тащить код:</p>

<p>``` ruby</p>

<pre><code>dependency 'AFNetworking', :git =&gt; 'https://github.com/gowalla/AFNetworking.git'
dependency 'AFNetworking', :git =&gt; 'https://github.com/gowalla/AFNetworking.git', :commit =&gt; '082f8319af'
</code></pre>

<p>```</p>

<h3>Точное управление зависимостями</h3>

<p>Часто, для разных таргетов в проекте необходимы разные зависимости. Классический случай: тестовый фреймворк нужен только для тестов. В этом случае, можно собрать несколько версий libPods:</p>

<p>``` ruby</p>

<pre><code>target :debug do
    dependency 'CocoaLumberjack'
end

target :test, :exclusive =&gt; true do
    dependency 'Kiwi'
end
</code></pre>

<p>```</p>

<p>Опция exclusive указывает на то, что в библиотеку включаются <em>только</em> указанные зависимости. Нужные библиотеки нужно будет прицепить куда надо ручками, но это не так уж и сложно.</p>

<h3>Грабли и бонусы</h3>

<p>Поскольку cocoapods  — молодой проект, то, естественно, не обходится без каких-то проблем. Впрочем, пока всё что я встречал - довольно легко решалось. Одной такой граблей была проблема с тем же злополучным RestKit: как оказалось, необходимо было вместо добавления существующей большой спеки, добавить штук пять под-спек (вида <code>RestKit/CoreData</code>). Впрочем, возможно это уже починили.</p>

<p>Другая проблема — xcodebuild на билд-сервере не видит схем внутри воркспейса. Для починки нужно один раз открыть воркспейс в XCode на машине, где происходит сборка. Впрочем, эта потеря времени должна компенсироваться наличием кеша для библиотек: лично у меня добавление RestKit в проект запросто добавляет лишние пять минут к сборке на сервере именно за счёт долгого <code>git clone</code>.</p>

<h2>Заключение</h2>

<p>В общем, по опыту тех нескольких проектов, где я использовал CocoaPods — впечатления очень хорошие. Довольно много времени экономится на добавлении и обновлении библиотек, да и единый их список для проекта очень удобен. Я очень надеюсь, что нам удастся встроить этот инструмент в стандартный процесс iOS-разработки в <a href="http://www.e-legion.ru/">e-Legion</a>, для чего, собственно я и создал это введение. Спасибо за внимание и пишите фидбеки.</p>

<p>Пока.</p>

<h2>P.S.</h2>

<p>Решил сменить дефолтную тему на <a href="http://zespia.tw/Octopress-Theme-Slash/">slash</a>. Как вам?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS-dev: первые впечатления. Всё остальное.]]></title>
    <link href="http://digal.github.com/blog/2011/11/30/ios-impressions-2/"/>
    <updated>2011-11-30T17:44:00+04:00</updated>
    <id>http://digal.github.com/blog/2011/11/30/ios-impressions-2</id>
    <content type="html"><![CDATA[<p>Итак, продолжаю описывать уже немного утрясшиеся впечатления от iOS-разработки. Если кто-то пропустил, то <a href="http://digal.github.com/blog/2011/11/22/ios-impressions/">вот первый пост</a>. Теперь немного расскажу об инструментах и экостистеме. Сразу оговорюсь, что поскольку "настоящим сварщиком" мне называться пока рано, я могу быть не в курсе источников и реальных причин каких-то недочётов. Например, я наверняка буду приписывать отдельным инструментам недостатки, происходящие от других элементов тулчейна или даже просто из сложившихся здесь традиций.</p>

<!--more-->


<h2>IDE</h2>

<p>Самый главный инструмент iOS-девелопера - это, конечно же, XCode. Этот инструмент вызывает смешанные чувства. С одной стороны, если сравнить его с таким монстром (в хорошем смысле) как IntelliJ IDEA, то чувствуется недостаток всяких приятных и ускоряющих работу неопытного девелопера фич (например, я не нашёл, как сгенерировать заготовки недостающих методов протокола). Естественно, и вполне в стиле Apple, нет никакого репозитория плагинов. Не обходится, к сожалению, без крэшей и странных багов. Диалог коммита в git, например, крэшит программу практически через раз, а в одном случае мне пришлось даже перезапустить систему, чтобы то ли XCode, то ли симулятор пришли в себя.</p>

<p>Довольно много сумятицы вносит, как XCode работает с файлами проекта: его структура и местоположение файлов на диске имеют друг с другом мало чего общего. Папки в навигаторе являются чисто "виртуальными" и при добавлении файлов в проект откуда-то ещё (например, из какой-нибудь опенсорсной библиотеки) в лучшем случае вы получите кашу из файлов в папке с проектом. В худшем - если забыть поставить галочку при добавлении - файл проекта просто сошлётся на них, а сами файлы останутся лежать где лежали, и, конечно, не попадут в VCS, и выяснится это, только когда проект откроют на другой машине. Я уже не говорю о том, что один и тот же файл можно добавить два раза, что ломает билд. Конечно, ко всему этому можно привыкнуть и делать всё аккуратно, но поначалу это вызывает путаницу.</p>

<p>С другой стороны, сделана эта IDE очень приятно, и, положа руку на сердце, можно сказать, всё действительно нужное для разработки под iOS и OSX там есть. Есть куча готовых шаблонов для приложений, поддержка svn и git (с учётом упомянутых выше проблем со стабильностью), средства юнит-тестирования и ряд основных рефакторингов. Дизайнер интерфейсов очень неплох (после ада андроидовских XML-ек с лейаутами), многие вещи делаются перетаскиванием стрелочек из одной области окна в другую. А уж после того как я увидел визуализацию найденных <a href="http://clang-analyzer.llvm.org/">static analyzer</a>-ом утечек памяти, я практически влюбился в этот инструмент.</p>

<p><img src="https://img.skitch.com/20111130-qknwak3rexswj8jk8snrjf4fh7.png"></p>

<p>Впрочем, отталкиваясь от опыта работы с IDEA, RubyMine и WebStorm, очень хотелось бы взглянуть на альтернативу от <a href="http://www.jetbrains.com/">JetBrains</a>: <a href="http://www.jetbrains.com/objc/">AppCode</a>. Если будет время - обязательно попробую и опишу впечатления.</p>

<h2>Пляски с криптографией</h2>

<p>Если кто-то вам скажет, что самая сложная и запутанная часть в программировании для iOS - синтаксис Objective-C, или управление памятью, плюньте этому человеку в лицо. Лично у меня самое большое количество негатива вызвала запутанная возня с сертификатами. Даже если вы работаете в компании с девелоперским аккаунтом (то есть половина бюрократии уже сделана за вас), то для разработки (не распространения) одного приложения вам будет необходимо:</p>

<ul>
<li>создать certificate signing request</li>
<li>с помощью него создать сертификат и положить его в кейчейн</li>
<li>создать app ID</li>
<li>создать provisioning profile для девайса (для симулятора не нужно, и на том спасибо)</li>
<li>создать provisioning profile для приложения и добавить туда себя и свой девайс. Впрочем тут можно срезать углы, поскольку при указании bundle id можно использовать wildcard. С другой стороны, при добавлении сюда ещё одного разработчика или девайса, необходимо перегенерировать и импортировать его в систему заново.</li>
</ul>


<p>Если представить себе что все эти артефакты имеют неприятное свойство "протухать" (то есть, имеют конечный срок действия), требуют для использования приватных ключей, которые лежат на машинах где был сделан signing request (а если ключа нет - то надо перегенерировать сертификат), умножить всё это на количество разработчиков в команде, а потом ещё раз на количество разрабатываемых приложений, то можно представить сколько нервов, времени и мата занимает вся эта возня. Я уже не говорю про то, на сколько граблей было наступлено при настройки headless сборки-проектов на билд-сервере. Codesign то в упор не видел кейчейна, то зачем-то требовал user interaction в виде окошечка подтверждения доступа к этому самому кейчейну. Впрочем, как и с другими "острыми углами", наступив с десяток граблей и наведя порядок в управлении сертификатами, ключами и профайлами, к этому можно привыкнуть и, в общем, даже жить.</p>

<h2>Управление зависимостями</h2>

<p>Управления зависимостями в obj-c нет как такового вообще. Библиотеки присоединяются к проекту либо в уже откомпилированном виде, либо в виде сорцовых файлов. И то и другое нужно держать в репозитории. Для особо продвинутых есть git submodules. Вообще, у меня такое ощущение, что использование любых сторонних библиотек не очень поощряется самим Apple и какой-то частью community. Мне же после java/scala/ruby/python-дева писательство велосипедов кажется уже такой явной глупостью, что это даже не требует каких-то объяснений. Немного порывшись в интернетах, я обнаружил несколько инструментов для управления проектами. Из них самым внятным и стабильными выглядит <a href="https://github.com/CocoaPods/CocoaPods">CocoaPods</a>, очень похожий на рубёвый bundler. Его я тоже собираюсь попробовать, как только будет возможность.</p>

<h2>Заключение</h2>

<p>Этот пост я писал очень уж долго и решил, что рискую оставить его пылиться на ноутбуке вечно. Так что, пожалуй, буду закругляться, несмотря на то что были ещё какие-то мысли и замечания. Может, когда-нибудь ещё наберётся каких-то вещей на ещё один пост. Так, например, полезный опыт приделывания xcode и консольных утилит к Jenkins и настройка непрерывного деплоя через <a href="testflightapp.com">TestFlight</a> вполне потянет на таковой, если дойдут руки. Пока же всем спасибо за внимание и удачно провести праздники :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS-dev: первые впечатления. Язык.]]></title>
    <link href="http://digal.github.com/blog/2011/11/22/ios-impressions/"/>
    <updated>2011-11-22T10:22:00+04:00</updated>
    <id>http://digal.github.com/blog/2011/11/22/ios-impressions</id>
    <content type="html"><![CDATA[<p>Недели три назад мне пришлось основательно взяться за разработку под iOS и (куда же тут без него) Objective-C. Из всего опыта была только прочитанная летом наполовину <a href="http://oreilly.com/catalog/9781449397296">книжка</a> по сабжу, пару раз открытый XCode, и попытка собрать <a href="http://www.scummvm.org/">ScummVM</a> для iPad из сорцов. Надо сказать что идея овладеть obj-c появилась у меня в голове ещё больше года назад (с появлением iPad), а после переезда на мак этому не оставалось уже никаких препятствий.</p>

<!--more-->


<p>Заранее извиняюсь у экспертов в iOS-деве за возможные ляпы: всё-таки, несколько недель это слишком мало чтобы досконально изучить все тонкости разработки под новую для себя платформу (но в самый раз чтобы зафиксировать впечатления, пока они не успели выветриться из головы). Если вы найдёте какую-то неточность или ошибку - пишите и я обязательно постараюсь её исправить.</p>

<h2>Тёплые ламповости</h2>

<p>Итак, первое что бросается в глаза тому, кто приходит писать под Cocoa (это, если кто не знает, UI-фреймворк в OSX/iOS) - непривычно выглядящий Objective-C. Многие ставят ему в вину необычный синтаксис для вызова методов (которые являются smalltalk-style посылкой сообщений). На самом деле, синтаксис любого языка это, конечно же дело вкуса, и, наверное, самая малая часть из того, к чему приходится привыкать при разработке под новую платформу.</p>

<p>С другой стороны, привычка (выработанная в Scala) выстраивать вызовы методов в длинные цепочки приводит к совершенно нечитаемым кускам кода:</p>

<p>``` objc</p>

<pre><code>[webView loadRequest:[NSURLRequest requestWithURL:[NSURL fileURLWithPath:[[NSBundle mainBundle] pathForResource:@"test" ofType:@"html"] isDirectory:NO]]];
</code></pre>

<p>```</p>

<p>Единственный способ сделать это читаемым - вынести результаты вызовов методов в отдельные переменные. Но даже это окончательно не решит проблему: даже простой вызов метода с четыремя параметрами вполне может не влезть в одну строку, благодаря необходимости указывать имена аргументов и любви создателей библиотек к длинными именам. Последнее, кстати, частично вызвано отсутствием хоть какой-либо системы неймспейсов: приходится следить за уникальностью имён классов, добавляя к ним префиксы.</p>

<p>Ешё одно наследие C, сильно раздражающее перебежчиков из других языков - необходимость создания отдельных заголовочных файлов (.h). Это сразу в два раза увеличивает количество сорцовых файлов в проекте, а любое более-менее серьёзное изменение требует правки сразу обоих файлов.</p>

<h2>Нераскрытые возможности</h2>

<p>Впрочем, это всё мелочи, с которыми можно смириться. Можно даже их любить, если вас греет ощущение использования тёплого лампового языка. От чего действительно становится немного грустно, так это (как ни странно) от его достоинств и клёвых фич. Здесь Objective-C немного напоминает JavaScript лет 5-10 назад, когда большинство программистов на нём просто до конца не понимали что им делать со всей этой динамичностью, прототипами и замыканиями.</p>

<p>Итак, как я уже говорил, вызов метода в Objective-C является передачей сообщения от одного объекта другому. Это очень похоже на то, как это сделано в Ruby. Предвидя возмущение некоторых поклонников Erlang от того факта что передача сообщений происходит синхронно (а поэтому сообщения там "ненастоящие"), надо заметить что впервые эта концепция и терминология была предложена в Smalltalk (если не раньше), лет эдак за 15 до Erlang.</p>

<p>Как и Ruby, Objective-C <a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtDynamicResolution.html">умеет</a> обрабатывать неизвестные сообщения (то есть те, для которых не написаны методы). Однако, в отличие от Ruby или Groovy, где возможности метапрограмминга используются на полную катушку, obj-c разработчики, похоже, рассматривают эту возможность скорее как метод расстановки костылей. Хотя лично мне кажется, что аналог <a href="http://guides.rubyonrails.org/active_record_querying.html#dynamic-finders">dynamic finders в activerecord</a> был бы отличным дополнением к core data.</p>

<p>Ещё одна относительно новая фича языка, блоки ("form of closures", как говорит википедия), практически не используется в полную силу. Похоже, ни разработчики библиотек, ни прикладные ios-девелоперы просто не понимают, зачем им это нужно. Хотя, в отличие от предыдущего примера с dynamic finders, мне удалось найти несколько библиотек, пытающихся прикрутить ФП к Objective-C. Самая развесистая - это, пожалуй, <a href="https://github.com/mogeneration/functionalkit/">FunctionalKit</a>.</p>

<h2>Остальное</h2>

<p>С остальными вещами всё более-менее понятно: это протоколы (читай интерфейсы), категории (иногда их ошибочно <a href="http://stackoverflow.com/questions/1244748/objective-c-category-compared-to-mixins">считают</a> миксинами, хотя они скорее являются формой манки-патчинга) и полуавтоматический менеджмент указателей. Последнее, наверное, пугает java- и других "высокоуровневых" девелоперов больше всего, однако на практике здесь всё просто. Хотя не к месту всунутый autorelease может доставить немало приятных минут в дебаггере, а устроить себе утечку памяти - вообще как нефиг делать. Всё это хорошо описано и давно используется в повседневной разработке.</p>

<p>Это пожалуй всё, что я хотел сказать об Objective-C. В следующем посте (или постах) я постараюсь рассказать об инструментах разработки и экосистеме этой платформы в целом.</p>
]]></content>
  </entry>
  
</feed>
