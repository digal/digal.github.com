<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ostrich | Лошоть и байты]]></title>
  <link href="http://digal.github.com/blog/categories/ostrich/atom.xml" rel="self"/>
  <link href="http://digal.github.com/"/>
  <updated>2012-06-07T12:33:33+04:00</updated>
  <id>http://digal.github.com/</id>
  <author>
    <name><![CDATA[Yuri Buyanov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Fixtures]]></title>
    <link href="http://digal.github.com/blog/2011/09/07/fixtures/"/>
    <updated>2011-09-07T09:46:00+04:00</updated>
    <id>http://digal.github.com/blog/2011/09/07/fixtures</id>
    <content type="html"><![CDATA[<p>В предыдущем посте я рассказывал об исполняемых конфигах ostrich и не упомянул особых их достоинств, кроме type safety и удобства работы с настройками со стороны приложения. На прошлой неделе я наткнулся на ещё один хороший юзкейс для таких конфигов.</p>

<p>Предположим, мы развёртываем наше приложение в разных окружениях (dev, test, prod), и в некоторых из них было бы здорово иметь в базе некоторые начальные данные для упрощения, например, процесса тестирования. Есть несколько достаточно тривиальных, но не очень удобных способов решения этой проблемы, особенно если загрузка этих начальных данных - часть автоматического развёртывания через CI-сервер. В скриптовых языках, где исполняемые файлы настроек - норма, такие данные (называемые fixtures) часто делаются частью конфига.</p>

<p>С ostrich реализация такой штуки становится делом буквально нескольких строк кода:</p>

<!--more-->


<p>Итак, для начала добавим соответствующее поле в наш базовый конфиг, он же конфиг по умолчанию. Мы воспользуемся тем, что scala - функциональный язык, а конфиг в свою очередь - это обычный scala-класс.</p>

<p>``` scala</p>

<pre><code>class DBConfig {

  ...

  /** Нужно ли сбросить и пересоздать базу? */
  var doReset = false

  /** Код, который нужно исполнить, если doReset == true */
  var fixtures: (DB =&gt; Unit) = {db =&gt; ()}  
}
</code></pre>

<p>```</p>

<p>По умолчанию, поле fixtures - это ничего не делающая функция. Теперь добавим в код, отвечающий за инициализацию базы, обработку новых полей:</p>

<p>``` scala</p>

<pre><code>class DB(val config: DBConfig) {

  Class.forName(config.driver)

  ...

  transaction {
    if (config.doReset) {
      //drop and create tables
      MySchema.drop
      MySchema.create

      //Run fixtures
      logger.info("Running fixtures")
      config.fixtures(this)
    }
  }
}
</code></pre>

<p>```</p>

<p>Ну и наконец выставим необходимое значение в поле fixtures в нужных конфигах</p>

<p>``` scala</p>

<pre><code>//myserver-test.scala
new MyServerConfig {

  ...

  dbConfig.doReset = true
  dbConfig.fixtures = { db =&gt;
    //create test user
    val usr = db.createUser("user@example.com", "password", "ru_RU")

    //set user roles
    db.assignRoleForUser(usr.id, Role.ADMIN)
    db.assignRoleForUser(usr.id, Role.STAFF)
  }
}
</code></pre>

<p>```</p>

<p>Вот, собственно, и всё: никаких самописных форматов для начальных данных, никаких SQL-файлов, которые нужно чинить при каждом изменении схемы. Мы описываем данные самым естественным для нас способом - в виде высокоуровневого кода, работающего с базой и использующего все возможности нашего приложения (и выбранного persistence-фреймворка). Более того, принцип используемый здесь можно легко применить не только к работе с базой, но и к любым другим частям приложения. Нужен тестовый файл в хитром формате, с которым работает наше приложение? Cоздаём его используя соответствующий API и он будет всегда актуален, даже если формат ещё не устаканился и разрабатывается параллельно с приложением.</p>

<p>В общем, с ostrich гибкость настройки приложения ограничена только фантазией разработчика. Я практически уверен, что это не последний пост, посвящённый этой библиотеке.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scala IRL. Часть 2: Готовим Домашнего Страуса]]></title>
    <link href="http://digal.github.com/blog/2011/08/29/scala-irl-2-ostrich/"/>
    <updated>2011-08-29T22:28:00+04:00</updated>
    <id>http://digal.github.com/blog/2011/08/29/scala-irl-2-ostrich</id>
    <content type="html"><![CDATA[<p>В предыдущем посте я мельком упомянул библиотеку ostrich в качестве инструмента для загрузки конфигов, в этом же постараюсь сделать более подробный обзор. Итак, <a href="github.com/twitter/ostrich">ostrich</a> - это внутренняя библиотека от разработчиков "твиттера", используемая в его компонентах. Несмотря на фичастость и навороченность, местами довольно-таки заметен её стиль, как библиотеки написанной в первую очередь "для себя".</p>

<p>Оstrich выполняет следующие задачи:</p>

<ul>
<li>загрузка и парсинг typesafe-конфигов (проще, говоря, конфигов в виде scala-кода)</li>
<li>сбор рантайм-статистики и разнообразных метрик</li>
<li>управление сервисами внутри процесса (запуск/остановка)</li>
<li>предоставление простенького, но расширяемого администраторского интерфейса через http/socket</li>
</ul>


<p>В этом посте я опишу работу с конфигами, а остальные возможности попробую раскрыть в последующих постах.</p>

<h2>Страус и конфиги</h2>

<p>Итак, ostrich предлагает использовать в качестве конфигов не просто структурированные текстовые файлы (json/xml/properties), а scala-код. Такой подход требует компиляции конфига при загрузке, но имеет ряд серьёзных преимуществ:</p>

<ul>
<li>типизация. Отпадает необходимость проверять и приводить значения из конфиг-файла к нужным типам</li>
<li>возможность писать произвольный код в конфигах, помимо простых значений. Например, использовать текущую дату в произвольном формате в имени лог-файла, или получить значения каких-то параметров из базы или стороннего сервиса. По сути, конфиг-файл становится тем, что называется extension point.</li>
<li>становятся ненужными отдельные классы, инкапсулирующие конфигурацию различных компонентов программы, или, по крайней мере, упрощается их создание.</li>
</ul>


<p>Для начала, нам нужно создать родительский класс для настроек. Чаще всего удобно сделать его же конфигом по умолчанию. Предположим, мы хотим сконфигурировать небольшое серверное приложение. Для этого ostrich предоставляет класс ServerConfig (являющийся наследником Config, предоставляющего базовые функции такие как компиляция, валидация и обязательные/необязательные поля).</p>

<p>``` scala</p>

<pre><code>import com.twitter.ostrich.admin._
import com.twitter.ostrich.admin.config._
import com.twitter.logging.config._
import com.twitter.logging.Level


class MyServerConfig extends ServerConfig[MyServer] {

  //ServerConfig, в отличие от просто Config, должен определить 
  //метод Apply, для создания инстанса сервера
  def apply(runtime: RuntimeEnvironment) = {
    new MyServer(this)
  }

  var port = 1234
  var workersNum = 10
  var baseUrl = "http://localhost:%s" format port
  var dbConfig = new DBConfig
}

case class DBConfig(
  var driver = "org.h2.Driver"
  var uri = "jdbc:h2:mem:"
  var create = true
)
</code></pre>

<p>```</p>

<p>Надо заметить, что мы используем в этом конфиге изменяемые переменные (<code>var</code>). В Scala это зачастую является признаком недостаточно функционального (декларативного) стиля, однако в данном случае это позволит писать лаконичные конфиги, выставляя значение полей простым присваиванием. Кроме того, этот же стиль используется при объявлении уже имеющихся в ServerConfig значений.</p>

<p>Итак, теперь наш конфиг для, например, тестового сервера, может выглядеть так:</p>

<p>``` scala</p>

<pre><code>new MyServerConfig {
  port = 80
  baseUrl = "http://test.myserver.com"

  dbConfig.uri = "jdbc:h2:/tmp/test.db;AUTO_SERVER=TRUE"
}
</code></pre>

<p>```</p>

<p>Вполне лаконично, и ничуть не хуже .properties и уж тем более XML-файла. Можем сохранить его под именем <code>test.scala</code>, тогда наш сервер мы сможем запускать как</p>

<p>``` bash</p>

<pre><code>java -jar my-server.jar -f ./test.scala
</code></pre>

<p>```</p>

<h2>Загрузка</h2>

<p>Теперь, наш файл настроек надо загрузить и использовать по назначению. Делать это логичнее всего поближе к точке входа, например в <code>main</code>. Путь к файлу можно передать с параметром <code>-f</code> при запуске приложения, а если его нет, то ostrich попытается найти его сам. Определение местоположения конфиг-файла - это то самое место, где становится видно, что проект делался для себя: ostrich ищет его в довольно специфических местах, пытаясь сначала выяснить имя jar-файла. Поэтому, проще всего всегда передавать путь к конфигу через <code>-f</code> плюс явно указать конфиг по умолчанию. Поскольку конфиг по умолчанию является обычным scala-классом, можно просто создать его инстанс в коде. Вот как выглядит загрузка и использование конфига у меня:</p>

<p>``` scala</p>

<pre><code>object MyServer {
  def main(args: Array[String]) {
    val runtime = RuntimeEnvironment(this, args)
    val server =
      if (runtime.configFile.exists) //если ostrich нашёл конфиг-файл 
        runtime.loadRuntimeConfig[Server]()
      else //default
        (new MyServerConfig)()(runtime)

    server.start()
  }
}

class MyServer(val config: MyServerConfig) 
{
  val db = new DB(config.dbConfig)

  def start() {
    //...
  }
}
</code></pre>

<p>```</p>

<p>Обратите внимание на строчку <code>(new MyServerConfig)()(runtime)</code>: сначала мы вызываем метод apply без параметров, а потом вызываем полученную функцию с параметром типа RuntimeEnvironment. При необходимости, этот способ можно расширить для загрузки различных конфигов по умолчанию, например в зависимости от <code>run.mode</code> в lift.</p>

<p>Я не использовал возможность ostrich объявлять поля как обязательные/опциональные, но промолчать о ней будет, наверное, неправильно. В приведённой к классу Config документации всё довольно просто:</p>

<p>``` scala</p>

<pre><code>//необязательное поле
var something = optional[Duration]

//обязательное поле
var level = required[Int]

//вычисляемое (lazily evaluated!) поле
var nextLevel = computed(level + 1)
</code></pre>

<p>```</p>

<h2>Конфигурация компонентов</h2>

<p>В вышеприведённом примере мы вынесли настройку базы данных в отдельный класс DBConfig. Иногда, со стороны приложения бывает удобно вынести конфигурацию в отдельный класс, но усложнять структуру конфиг-файла не хочется. Хорошим примером является случай, когда конфигурируемый компонент находится в другом (под)проекте. В этом случае, конфиг можно объявить трейтом и подмешать его в основной конфиг</p>

<p>Представим, что мы хотим добавить в наш север небольшой внутренний почтовый сервис для отсылки писем пользователям.</p>

<p>``` scala</p>

<pre><code>trait MailConfig {
  def smtpServer:  String
  def smtpPort:    String
  def fromAddress: String  
}

class MailManager(val config: MailConfig) {
  ...
}
</code></pre>

<p>```</p>

<p>Теперь мы просто подмешиваем трейт в наш основной конфиг, перегружая его методы нашими <code>var</code>ами:</p>

<p>``` scala</p>

<pre><code>class MyServerConfig 
extends ServerConfig[MyServer] 
with MailConfig
{
  ...

  var smtpServer = required[String]
  var smtpPort = 24
  var fromAddress = "noreply@domain.com"
}
</code></pre>

<p>```</p>

<p>В нашем конфиг-файле (<code>test.scala</code>) эти поля будут работать точно так же как и все остальные. При инстанциировании менеджера можно просто передать ему общий конфиг:</p>

<p>``` scala</p>

<pre><code>class MyServer(val config: MyServerConfig) 
{
  val db = new DB(config.dbConfig)
  val mailer = new MailManager(config)

  ...
}
</code></pre>

<p>```</p>

<p>Также, в отдельный трейт можно вынести готовые значения для настроек если они представляют собой что-то более сложное чем простые значения.</p>

<p>Вот собственно и всё что я хотел рассказать об использовании ostrich для конфигурирования. Я намеренно не стал рассматривать имеющиеся в ServerConfig поля для настройки логгинга, статистики и админки. Мы вернёмся к ним попозже, когда я буду рассказывать о соответствующих фичах "страуса".</p>
]]></content>
  </entry>
  
</feed>
