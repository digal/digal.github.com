<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: libraries | Лошоть и байты]]></title>
  <link href="http://digal.github.com/blog/categories/libraries/atom.xml" rel="self"/>
  <link href="http://digal.github.com/"/>
  <updated>2012-12-21T00:23:01+04:00</updated>
  <id>http://digal.github.com/</id>
  <author>
    <name><![CDATA[Yuri Buyanov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Squeryl: основы]]></title>
    <link href="http://digal.github.com/blog/2011/09/25/squeryl/"/>
    <updated>2011-09-25T21:46:00+04:00</updated>
    <id>http://digal.github.com/blog/2011/09/25/squeryl</id>
    <content type="html"><![CDATA[<p>Этим и следующим постом (который, надеюсь, будет вот совсем скоро) я хочу познакомить вас с замечательной ORM-библиотекой для scala, которую сейчас использую в одном из рабочих проектов. Не надо пугаться аббревиатуры ORM: возожности маппинга к объектам здесь принципиально реализованы на совсем базовом уровне, а вот симпатичный DSL для запросов стоит того, чтобы на него взглянуть.</p>

<!--more-->


<p>Каждый, кто когда-либо пытался использовать "традиционные" ORM типа Hibernate знает, что тот уровень абстракций, которые они предоставляют, хорошо работает только для простых запросов. Как только возникает потребность сделать выборку более или менее сложную либо по условию, либо по выдаваемому набору данных, разработчику приходится начинать сражение с высокоуровневым языком запросов (типа HQL), использование которого несёт в себе сразу ряд проблем. Во-первых, это ещё один язык запросов, похожий на SQL, но им не являющийся. Во-вторых, сразу теряются остатки type safety. В-третьих, при любом изменении схемы нужно проверять и править ручками <strong>все</strong> строки запросов в коде. Добавьте сюда сложную внутреннюю логику ORM, когда программисту довольно сложно сходу понять, когда и какие именно запросы будут сделаны к базе и частенько страдающую производительность.</p>

<p><a href="http://squeryl.org/">Squeryl</a> - это scala-библиотека, призванная решить хотя бы часть этих проблем, и делает она это с широкомасштабным применением средств языка, а именно заточенностью под DSL и строгой типизацией всего что только можно. Таким образом, запросы имеют структуру, похожую на обычный SQL, являясь при этом scala-кодом. Scala-код, в отличие от SQL-запросов, тщательно проверяется компилятором, который сделает вам ататат, как только вы попытаетесь вписать строку в столбец типа Int или хотя бы сделать сравнение столбца типа Date с булевским значением.</p>

<h2>Инициализация</h2>

<p>Итак, для начала нужно инициализировать драйвер и реализовать фабрику сессий. Не надо пугаться названия, это всего лишь функция, возвращающая экземпляр класса Session:</p>

<p>``` scala</p>

<pre><code>import org.squeryl.SessionFactory

  Class.forName("org.h2.Driver");

  SessionFactory.concreteFactory = Some { ()=&gt;
    Session.create(
      java.sql.DriverManager.getConnection("jdbc:h2:mem:"),
      new H2Adapter
    )
  } 
</code></pre>

<p>```</p>

<p>Это довольно простая реализация, в реальном проекте скорее всего будет уместнее использовать connection pool, типа <a href="http://commons.apache.org/dbcp/">DBCP</a> или <a href="http://jolbox.com/">BoneCP</a>.</p>

<h2>Транзакции</h2>

<p>С транзакциями всё просто: транзакция осуществляется с помощью двух методов <code>transaction</code> и <code>inTransaction</code>, которые, принимая на вход функцию, оборачивают её выполнение в транзакцию.</p>

<p>``` scala</p>

<pre><code>import org.squeryl.PrimitiveTypeMode._

transaction {

  //операции с данными ...

} //коммит транзакции
</code></pre>

<p>```</p>

<p>Их отличие состоит в том, что <code>transaction</code> всегда открывает новую транзакцию перед началом выполнения блока и коммитит после завершения, a <code>inTransaction</code> делает это только в том случае, если не находится внутри другой транзакции.</p>

<h2>Схема.</h2>

<p>Следующим шагом, как и в других ORM, будет объявление схемы. Есть два режима работы со squeryl: использование примитивных типов (PrimitiveTypeMode) и типов-врапперов (CustomTypeMode), которые могут, например, включать в себя валидацию. Собственно для работы с DSL, необходим импорт членов одного из этих объектов (как это сделано в первой строчке предыдущего листинга).</p>

<p>Классы схемы могут быть любыми скаловскими классами, поля, объявленные в конструкторе будут столбцами. Поля могут быть как mutable, так и immutable. Я предпочитаю для большей ясности использовать второй вариант в сочетании с case-классами и при необходимости просто вызывать метод copy. Однако, стоит заметить что этот способ имеет свои недостатки (например, не будет работать "из коробки" optimistic concurrency control, поскольку поле с версией не будет копироваться при вызове copy).</p>

<p>``` scala</p>

<pre><code>case class User(
  id:     Long = 0,
  @Column(length = 256)
  email:  String,
  name:   String,
  rating: Int = 0,
) extends KeyedEntity[Long]
</code></pre>

<p>```</p>

<p>Трейт KeyedEntity просто говорит Squeryl что id является первичным ключом, позволяя, например, упростить поиск записи по id до вызова единственного метода <code>lookup(id)</code> над таблицей.</p>

<p>Таблицы и связи между ними описываются в классе, отнаследованным от Schema, в большинстве случаев можно сделать его синглтоном:</p>

<p>``` scala</p>

<pre><code>object MySchema extends Schema {
  val users = table[User]

  on(users) { u =&gt; declare(
      u.id    is (autoIncremented),
      u.email is (unique)
    )
  }
}
</code></pre>

<p>```</p>

<p>Наличие схемы, как в любом приличном ORM избавляет необходимости писать тонны SQL CREATE ручками. Для создания схемы в базе можно воспользоваться методом <code>create</code>.</p>

<p>``` scala</p>

<pre><code>transaction {
  MySchema.create  
}
</code></pre>

<p>```</p>

<p>Аналогично, для импорта схемы в виде SQL, есть метод <code>printDdl</code>, а для очистки базы - <code>drop</code>.</p>

<h2>Insert</h2>

<p>Итак, мы объявили схему и можем приступить к тому, ради чего, собственно, всё и затевалось. Для начала создадим несколько пользователей:</p>

<p>``` scala</p>

<pre><code>import MySchema._

val vasya = users.insert(new User("vasya@example.com", "Vasya Poupkine"))
val masha = users.insert(new User("masha@example.com", "Masha Petrova"))
</code></pre>

<p>```</p>

<h2>Select</h2>

<p>Select в squeryl является практически двойником оного в SQL за исключением того, написан на Scala со всеми вытекающими плюшками:</p>

<p>``` scala</p>

<pre><code>import MySchema._

val nullRated = 
  from(users) ( u =&gt;
    select(u)
    where(u.rating === 0) //(1)
  )

val mails = 
  from(users) ( u =&gt;
    select(u.email)
  )

val idsWithMails = 
  from(users) ( u =&gt;
    select(u.id, u.email)
  )
</code></pre>

<p>```</p>

<p>Обратите внимание на тройное <code>===</code> (1). В отличие от обычного двойного <code>==</code>  - это не встроенный в scala оператор, а конструкция DSL Squeryl.
Трейт <code>KeyedEntity</code> даёт нам возможность использовать упрощённый синтаксис для поиска записи по id:</p>

<p>``` scala</p>

<pre><code>val zeroUser: Option[User] = users.lookup(id)
</code></pre>

<p>```</p>

<h2>Update</h2>

<p>Операция обновления в squeryl поддерживает два вида синтаксиса: частичное и полное обновление. Полное обновление, как следует из названия, использует в качестве источника обновлённых данных объект целиком. Поскольку в нашем примере классы целиком иммутабельны, мы будем подсовывать в update объекты, созданные через метод copy.</p>

<p>``` scala</p>

<pre><code>val updatedVasya = vasya.copy(rating = vasya.rating + 1)
users.update(updatedVasya)
</code></pre>

<p>```</p>

<p>Полный update всегда обновляет только одну запись, поэтому ничего не возвращает.</p>

<p>При частичном обновлении используется конструкция DSL, похожая на ту, которую мы использовали в select:</p>

<p>``` scala</p>

<pre><code>val updated = 
  update(users) ( u =&gt;
    set(u.rating := u.rating.~ + 1) //(1)
    where(u.name like "%Vasya%")    //(2)
  )

println("%s Vasyas rated" format updated) 
</code></pre>

<p>```</p>

<p>Как это принято в JDBC, update возвращает количество обновлённых записей.</p>

<p>Опять обратим внимание (1) на использование DSL-оператора присваивания (<code>:=</code>) вместо 'родного' <code>=</code> и на, конструкцию <code>.~</code>, применяющуюся в PrimitiveTypeMode для того, чтобы компилятор не путал оператор <code>+</code> у скаловского Int с таким же оператором в DSL. Вместо конструкци <code>field.~ + value</code> можно использовать <code>field plus value</code>, кому как нравится. Кроме того, мы использовали (2) ещё один оператор сравнения - SQL LIKE.</p>

<h2>Delete</h2>

<p>Удаление выполняется аналогично: либо по id (для классов, с примешанным KeyedEntity) либо по условию.</p>

<p>``` scala</p>

<pre><code>users.deleted(1)

val deleted = 
  users.deleteWhere( u =&gt;
    u.rating.~ &lt; 0
  )

println("%s users deleted" format deleted)
</code></pre>

<p>```</p>

<h2>Продолжение следует</h2>

<p>В следующем посте я постараюсь рассмотреть "продвинутые" функции squeryl: джойны, связи 1-to-many и many-to-many, составные запросы, итд. И ещё постараюсь не забыть пройтись с критикой по тем местам библиотеки, которые ещё требуют полировки. Критика и отзывы, как обычно приветствуются. До встречи.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fixtures]]></title>
    <link href="http://digal.github.com/blog/2011/09/07/fixtures/"/>
    <updated>2011-09-07T09:46:00+04:00</updated>
    <id>http://digal.github.com/blog/2011/09/07/fixtures</id>
    <content type="html"><![CDATA[<p>В предыдущем посте я рассказывал об исполняемых конфигах ostrich и не упомянул особых их достоинств, кроме type safety и удобства работы с настройками со стороны приложения. На прошлой неделе я наткнулся на ещё один хороший юзкейс для таких конфигов.</p>

<p>Предположим, мы развёртываем наше приложение в разных окружениях (dev, test, prod), и в некоторых из них было бы здорово иметь в базе некоторые начальные данные для упрощения, например, процесса тестирования. Есть несколько достаточно тривиальных, но не очень удобных способов решения этой проблемы, особенно если загрузка этих начальных данных - часть автоматического развёртывания через CI-сервер. В скриптовых языках, где исполняемые файлы настроек - норма, такие данные (называемые fixtures) часто делаются частью конфига.</p>

<p>С ostrich реализация такой штуки становится делом буквально нескольких строк кода:</p>

<!--more-->


<p>Итак, для начала добавим соответствующее поле в наш базовый конфиг, он же конфиг по умолчанию. Мы воспользуемся тем, что scala - функциональный язык, а конфиг в свою очередь - это обычный scala-класс.</p>

<p>``` scala</p>

<pre><code>class DBConfig {

  ...

  /** Нужно ли сбросить и пересоздать базу? */
  var doReset = false

  /** Код, который нужно исполнить, если doReset == true */
  var fixtures: (DB =&gt; Unit) = {db =&gt; ()}  
}
</code></pre>

<p>```</p>

<p>По умолчанию, поле fixtures - это ничего не делающая функция. Теперь добавим в код, отвечающий за инициализацию базы, обработку новых полей:</p>

<p>``` scala</p>

<pre><code>class DB(val config: DBConfig) {

  Class.forName(config.driver)

  ...

  transaction {
    if (config.doReset) {
      //drop and create tables
      MySchema.drop
      MySchema.create

      //Run fixtures
      logger.info("Running fixtures")
      config.fixtures(this)
    }
  }
}
</code></pre>

<p>```</p>

<p>Ну и наконец выставим необходимое значение в поле fixtures в нужных конфигах</p>

<p>``` scala</p>

<pre><code>//myserver-test.scala
new MyServerConfig {

  ...

  dbConfig.doReset = true
  dbConfig.fixtures = { db =&gt;
    //create test user
    val usr = db.createUser("user@example.com", "password", "ru_RU")

    //set user roles
    db.assignRoleForUser(usr.id, Role.ADMIN)
    db.assignRoleForUser(usr.id, Role.STAFF)
  }
}
</code></pre>

<p>```</p>

<p>Вот, собственно, и всё: никаких самописных форматов для начальных данных, никаких SQL-файлов, которые нужно чинить при каждом изменении схемы. Мы описываем данные самым естественным для нас способом - в виде высокоуровневого кода, работающего с базой и использующего все возможности нашего приложения (и выбранного persistence-фреймворка). Более того, принцип используемый здесь можно легко применить не только к работе с базой, но и к любым другим частям приложения. Нужен тестовый файл в хитром формате, с которым работает наше приложение? Cоздаём его используя соответствующий API и он будет всегда актуален, даже если формат ещё не устаканился и разрабатывается параллельно с приложением.</p>

<p>В общем, с ostrich гибкость настройки приложения ограничена только фантазией разработчика. Я практически уверен, что это не последний пост, посвящённый этой библиотеке.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scala IRL. Часть 2: Готовим Домашнего Страуса]]></title>
    <link href="http://digal.github.com/blog/2011/08/29/scala-irl-2-ostrich/"/>
    <updated>2011-08-29T22:28:00+04:00</updated>
    <id>http://digal.github.com/blog/2011/08/29/scala-irl-2-ostrich</id>
    <content type="html"><![CDATA[<p>В предыдущем посте я мельком упомянул библиотеку ostrich в качестве инструмента для загрузки конфигов, в этом же постараюсь сделать более подробный обзор. Итак, <a href="github.com/twitter/ostrich">ostrich</a> - это внутренняя библиотека от разработчиков "твиттера", используемая в его компонентах. Несмотря на фичастость и навороченность, местами довольно-таки заметен её стиль, как библиотеки написанной в первую очередь "для себя".</p>

<p>Оstrich выполняет следующие задачи:</p>

<ul>
<li>загрузка и парсинг typesafe-конфигов (проще, говоря, конфигов в виде scala-кода)</li>
<li>сбор рантайм-статистики и разнообразных метрик</li>
<li>управление сервисами внутри процесса (запуск/остановка)</li>
<li>предоставление простенького, но расширяемого администраторского интерфейса через http/socket</li>
</ul>


<p>В этом посте я опишу работу с конфигами, а остальные возможности попробую раскрыть в последующих постах.</p>

<h2>Страус и конфиги</h2>

<p>Итак, ostrich предлагает использовать в качестве конфигов не просто структурированные текстовые файлы (json/xml/properties), а scala-код. Такой подход требует компиляции конфига при загрузке, но имеет ряд серьёзных преимуществ:</p>

<ul>
<li>типизация. Отпадает необходимость проверять и приводить значения из конфиг-файла к нужным типам</li>
<li>возможность писать произвольный код в конфигах, помимо простых значений. Например, использовать текущую дату в произвольном формате в имени лог-файла, или получить значения каких-то параметров из базы или стороннего сервиса. По сути, конфиг-файл становится тем, что называется extension point.</li>
<li>становятся ненужными отдельные классы, инкапсулирующие конфигурацию различных компонентов программы, или, по крайней мере, упрощается их создание.</li>
</ul>


<p>Для начала, нам нужно создать родительский класс для настроек. Чаще всего удобно сделать его же конфигом по умолчанию. Предположим, мы хотим сконфигурировать небольшое серверное приложение. Для этого ostrich предоставляет класс ServerConfig (являющийся наследником Config, предоставляющего базовые функции такие как компиляция, валидация и обязательные/необязательные поля).</p>

<p>``` scala</p>

<pre><code>import com.twitter.ostrich.admin._
import com.twitter.ostrich.admin.config._
import com.twitter.logging.config._
import com.twitter.logging.Level


class MyServerConfig extends ServerConfig[MyServer] {

  //ServerConfig, в отличие от просто Config, должен определить 
  //метод Apply, для создания инстанса сервера
  def apply(runtime: RuntimeEnvironment) = {
    new MyServer(this)
  }

  var port = 1234
  var workersNum = 10
  var baseUrl = "http://localhost:%s" format port
  var dbConfig = new DBConfig
}

case class DBConfig(
  var driver = "org.h2.Driver"
  var uri = "jdbc:h2:mem:"
  var create = true
)
</code></pre>

<p>```</p>

<p>Надо заметить, что мы используем в этом конфиге изменяемые переменные (<code>var</code>). В Scala это зачастую является признаком недостаточно функционального (декларативного) стиля, однако в данном случае это позволит писать лаконичные конфиги, выставляя значение полей простым присваиванием. Кроме того, этот же стиль используется при объявлении уже имеющихся в ServerConfig значений.</p>

<p>Итак, теперь наш конфиг для, например, тестового сервера, может выглядеть так:</p>

<p>``` scala</p>

<pre><code>new MyServerConfig {
  port = 80
  baseUrl = "http://test.myserver.com"

  dbConfig.uri = "jdbc:h2:/tmp/test.db;AUTO_SERVER=TRUE"
}
</code></pre>

<p>```</p>

<p>Вполне лаконично, и ничуть не хуже .properties и уж тем более XML-файла. Можем сохранить его под именем <code>test.scala</code>, тогда наш сервер мы сможем запускать как</p>

<p>``` bash</p>

<pre><code>java -jar my-server.jar -f ./test.scala
</code></pre>

<p>```</p>

<h2>Загрузка</h2>

<p>Теперь, наш файл настроек надо загрузить и использовать по назначению. Делать это логичнее всего поближе к точке входа, например в <code>main</code>. Путь к файлу можно передать с параметром <code>-f</code> при запуске приложения, а если его нет, то ostrich попытается найти его сам. Определение местоположения конфиг-файла - это то самое место, где становится видно, что проект делался для себя: ostrich ищет его в довольно специфических местах, пытаясь сначала выяснить имя jar-файла. Поэтому, проще всего всегда передавать путь к конфигу через <code>-f</code> плюс явно указать конфиг по умолчанию. Поскольку конфиг по умолчанию является обычным scala-классом, можно просто создать его инстанс в коде. Вот как выглядит загрузка и использование конфига у меня:</p>

<p>``` scala</p>

<pre><code>object MyServer {
  def main(args: Array[String]) {
    val runtime = RuntimeEnvironment(this, args)
    val server =
      if (runtime.configFile.exists) //если ostrich нашёл конфиг-файл 
        runtime.loadRuntimeConfig[Server]()
      else //default
        (new MyServerConfig)()(runtime)

    server.start()
  }
}

class MyServer(val config: MyServerConfig) 
{
  val db = new DB(config.dbConfig)

  def start() {
    //...
  }
}
</code></pre>

<p>```</p>

<p>Обратите внимание на строчку <code>(new MyServerConfig)()(runtime)</code>: сначала мы вызываем метод apply без параметров, а потом вызываем полученную функцию с параметром типа RuntimeEnvironment. При необходимости, этот способ можно расширить для загрузки различных конфигов по умолчанию, например в зависимости от <code>run.mode</code> в lift.</p>

<p>Я не использовал возможность ostrich объявлять поля как обязательные/опциональные, но промолчать о ней будет, наверное, неправильно. В приведённой к классу Config документации всё довольно просто:</p>

<p>``` scala</p>

<pre><code>//необязательное поле
var something = optional[Duration]

//обязательное поле
var level = required[Int]

//вычисляемое (lazily evaluated!) поле
var nextLevel = computed(level + 1)
</code></pre>

<p>```</p>

<h2>Конфигурация компонентов</h2>

<p>В вышеприведённом примере мы вынесли настройку базы данных в отдельный класс DBConfig. Иногда, со стороны приложения бывает удобно вынести конфигурацию в отдельный класс, но усложнять структуру конфиг-файла не хочется. Хорошим примером является случай, когда конфигурируемый компонент находится в другом (под)проекте. В этом случае, конфиг можно объявить трейтом и подмешать его в основной конфиг</p>

<p>Представим, что мы хотим добавить в наш север небольшой внутренний почтовый сервис для отсылки писем пользователям.</p>

<p>``` scala</p>

<pre><code>trait MailConfig {
  def smtpServer:  String
  def smtpPort:    String
  def fromAddress: String  
}

class MailManager(val config: MailConfig) {
  ...
}
</code></pre>

<p>```</p>

<p>Теперь мы просто подмешиваем трейт в наш основной конфиг, перегружая его методы нашими <code>var</code>ами:</p>

<p>``` scala</p>

<pre><code>class MyServerConfig 
extends ServerConfig[MyServer] 
with MailConfig
{
  ...

  var smtpServer = required[String]
  var smtpPort = 24
  var fromAddress = "noreply@domain.com"
}
</code></pre>

<p>```</p>

<p>В нашем конфиг-файле (<code>test.scala</code>) эти поля будут работать точно так же как и все остальные. При инстанциировании менеджера можно просто передать ему общий конфиг:</p>

<p>``` scala</p>

<pre><code>class MyServer(val config: MyServerConfig) 
{
  val db = new DB(config.dbConfig)
  val mailer = new MailManager(config)

  ...
}
</code></pre>

<p>```</p>

<p>Также, в отдельный трейт можно вынести готовые значения для настроек если они представляют собой что-то более сложное чем простые значения.</p>

<p>Вот собственно и всё что я хотел рассказать об использовании ostrich для конфигурирования. Я намеренно не стал рассматривать имеющиеся в ServerConfig поля для настройки логгинга, статистики и админки. Мы вернёмся к ним попозже, когда я буду рассказывать о соответствующих фичах "страуса".</p>
]]></content>
  </entry>
  
</feed>
