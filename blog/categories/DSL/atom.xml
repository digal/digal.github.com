<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: DSL | Лошоть и байты]]></title>
  <link href="http://digal.github.com/blog/categories/dsl/atom.xml" rel="self"/>
  <link href="http://digal.github.com/"/>
  <updated>2012-06-07T00:44:42+04:00</updated>
  <id>http://digal.github.com/</id>
  <author>
    <name><![CDATA[Yuri Buyanov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Squeryl: основы]]></title>
    <link href="http://digal.github.com/blog/2011/09/25/squeryl/"/>
    <updated>2011-09-25T21:46:00+04:00</updated>
    <id>http://digal.github.com/blog/2011/09/25/squeryl</id>
    <content type="html"><![CDATA[<p>Этим и следующим постом (который, надеюсь, будет вот совсем скоро) я хочу познакомить вас с замечательной ORM-библиотекой для scala, которую сейчас использую в одном из рабочих проектов. Не надо пугаться аббревиатуры ORM: возожности маппинга к объектам здесь принципиально реализованы на совсем базовом уровне, а вот симпатичный DSL для запросов стоит того, чтобы на него взглянуть.</p>

<!--more-->


<p>Каждый, кто когда-либо пытался использовать "традиционные" ORM типа Hibernate знает, что тот уровень абстракций, которые они предоставляют, хорошо работает только для простых запросов. Как только возникает потребность сделать выборку более или менее сложную либо по условию, либо по выдаваемому набору данных, разработчику приходится начинать сражение с высокоуровневым языком запросов (типа HQL), использование которого несёт в себе сразу ряд проблем. Во-первых, это ещё один язык запросов, похожий на SQL, но им не являющийся. Во-вторых, сразу теряются остатки type safety. В-третьих, при любом изменении схемы нужно проверять и править ручками <strong>все</strong> строки запросов в коде. Добавьте сюда сложную внутреннюю логику ORM, когда программисту довольно сложно сходу понять, когда и какие именно запросы будут сделаны к базе и частенько страдающую производительность.</p>

<p><a href="http://squeryl.org/">Squeryl</a> - это scala-библиотека, призванная решить хотя бы часть этих проблем, и делает она это с широкомасштабным применением средств языка, а именно заточенностью под DSL и строгой типизацией всего что только можно. Таким образом, запросы имеют структуру, похожую на обычный SQL, являясь при этом scala-кодом. Scala-код, в отличие от SQL-запросов, тщательно проверяется компилятором, который сделает вам ататат, как только вы попытаетесь вписать строку в столбец типа Int или хотя бы сделать сравнение столбца типа Date с булевским значением.</p>

<h2>Инициализация</h2>

<p>Итак, для начала нужно инициализировать драйвер и реализовать фабрику сессий. Не надо пугаться названия, это всего лишь функция, возвращающая экземпляр класса Session:</p>

<p>``` scala</p>

<pre><code>import org.squeryl.SessionFactory

  Class.forName("org.h2.Driver");

  SessionFactory.concreteFactory = Some { ()=&gt;
    Session.create(
      java.sql.DriverManager.getConnection("jdbc:h2:mem:"),
      new H2Adapter
    )
  } 
</code></pre>

<p>```</p>

<p>Это довольно простая реализация, в реальном проекте скорее всего будет уместнее использовать connection pool, типа <a href="http://commons.apache.org/dbcp/">DBCP</a> или <a href="http://jolbox.com/">BoneCP</a>.</p>

<h2>Транзакции</h2>

<p>С транзакциями всё просто: транзакция осуществляется с помощью двух методов <code>transaction</code> и <code>inTransaction</code>, которые, принимая на вход функцию, оборачивают её выполнение в транзакцию.</p>

<p>``` scala</p>

<pre><code>import org.squeryl.PrimitiveTypeMode._

transaction {

  //операции с данными ...

} //коммит транзакции
</code></pre>

<p>```</p>

<p>Их отличие состоит в том, что <code>transaction</code> всегда открывает новую транзакцию перед началом выполнения блока и коммитит после завершения, a <code>inTransaction</code> делает это только в том случае, если не находится внутри другой транзакции.</p>

<h2>Схема.</h2>

<p>Следующим шагом, как и в других ORM, будет объявление схемы. Есть два режима работы со squeryl: использование примитивных типов (PrimitiveTypeMode) и типов-врапперов (CustomTypeMode), которые могут, например, включать в себя валидацию. Собственно для работы с DSL, необходим импорт членов одного из этих объектов (как это сделано в первой строчке предыдущего листинга).</p>

<p>Классы схемы могут быть любыми скаловскими классами, поля, объявленные в конструкторе будут столбцами. Поля могут быть как mutable, так и immutable. Я предпочитаю для большей ясности использовать второй вариант в сочетании с case-классами и при необходимости просто вызывать метод copy. Однако, стоит заметить что этот способ имеет свои недостатки (например, не будет работать "из коробки" optimistic concurrency control, поскольку поле с версией не будет копироваться при вызове copy).</p>

<p>``` scala</p>

<pre><code>case class User(
  id:     Long = 0,
  @Column(length = 256)
  email:  String,
  name:   String,
  rating: Int = 0,
) extends KeyedEntity[Long]
</code></pre>

<p>```</p>

<p>Трейт KeyedEntity просто говорит Squeryl что id является первичным ключом, позволяя, например, упростить поиск записи по id до вызова единственного метода <code>lookup(id)</code> над таблицей.</p>

<p>Таблицы и связи между ними описываются в классе, отнаследованным от Schema, в большинстве случаев можно сделать его синглтоном:</p>

<p>``` scala</p>

<pre><code>object MySchema extends Schema {
  val users = table[User]

  on(users) { u =&gt; declare(
      u.id    is (autoIncremented),
      u.email is (unique)
    )
  }
}
</code></pre>

<p>```</p>

<p>Наличие схемы, как в любом приличном ORM избавляет необходимости писать тонны SQL CREATE ручками. Для создания схемы в базе можно воспользоваться методом <code>create</code>.</p>

<p>``` scala</p>

<pre><code>transaction {
  MySchema.create  
}
</code></pre>

<p>```</p>

<p>Аналогично, для импорта схемы в виде SQL, есть метод <code>printDdl</code>, а для очистки базы - <code>drop</code>.</p>

<h2>Insert</h2>

<p>Итак, мы объявили схему и можем приступить к тому, ради чего, собственно, всё и затевалось. Для начала создадим несколько пользователей:</p>

<p>``` scala</p>

<pre><code>import MySchema._

val vasya = users.insert(new User("vasya@example.com", "Vasya Poupkine"))
val masha = users.insert(new User("masha@example.com", "Masha Petrova"))
</code></pre>

<p>```</p>

<h2>Select</h2>

<p>Select в squeryl является практически двойником оного в SQL за исключением того, написан на Scala со всеми вытекающими плюшками:</p>

<p>``` scala</p>

<pre><code>import MySchema._

val nullRated = 
  from(users) ( u =&gt;
    select(u)
    where(u.rating === 0) //(1)
  )

val mails = 
  from(users) ( u =&gt;
    select(u.email)
  )

val idsWithMails = 
  from(users) ( u =&gt;
    select(u.id, u.email)
  )
</code></pre>

<p>```</p>

<p>Обратите внимание на тройное <code>===</code> (1). В отличие от обычного двойного <code>==</code>  - это не встроенный в scala оператор, а конструкция DSL Squeryl.
Трейт <code>KeyedEntity</code> даёт нам возможность использовать упрощённый синтаксис для поиска записи по id:</p>

<p>``` scala</p>

<pre><code>val zeroUser: Option[User] = users.lookup(id)
</code></pre>

<p>```</p>

<h2>Update</h2>

<p>Операция обновления в squeryl поддерживает два вида синтаксиса: частичное и полное обновление. Полное обновление, как следует из названия, использует в качестве источника обновлённых данных объект целиком. Поскольку в нашем примере классы целиком иммутабельны, мы будем подсовывать в update объекты, созданные через метод copy.</p>

<p>``` scala</p>

<pre><code>val updatedVasya = vasya.copy(rating = vasya.rating + 1)
users.update(updatedVasya)
</code></pre>

<p>```</p>

<p>Полный update всегда обновляет только одну запись, поэтому ничего не возвращает.</p>

<p>При частичном обновлении используется конструкция DSL, похожая на ту, которую мы использовали в select:</p>

<p>``` scala</p>

<pre><code>val updated = 
  update(users) ( u =&gt;
    set(u.rating := u.rating.~ + 1) //(1)
    where(u.name like "%Vasya%")    //(2)
  )

println("%s Vasyas rated" format updated) 
</code></pre>

<p>```</p>

<p>Как это принято в JDBC, update возвращает количество обновлённых записей.</p>

<p>Опять обратим внимание (1) на использование DSL-оператора присваивания (<code>:=</code>) вместо 'родного' <code>=</code> и на, конструкцию <code>.~</code>, применяющуюся в PrimitiveTypeMode для того, чтобы компилятор не путал оператор <code>+</code> у скаловского Int с таким же оператором в DSL. Вместо конструкци <code>field.~ + value</code> можно использовать <code>field plus value</code>, кому как нравится. Кроме того, мы использовали (2) ещё один оператор сравнения - SQL LIKE.</p>

<h2>Delete</h2>

<p>Удаление выполняется аналогично: либо по id (для классов, с примешанным KeyedEntity) либо по условию.</p>

<p>``` scala</p>

<pre><code>users.deleted(1)

val deleted = 
  users.deleteWhere( u =&gt;
    u.rating.~ &lt; 0
  )

println("%s users deleted" format deleted)
</code></pre>

<p>```</p>

<h2>Продолжение следует</h2>

<p>В следующем посте я постараюсь рассмотреть "продвинутые" функции squeryl: джойны, связи 1-to-many и many-to-many, составные запросы, итд. И ещё постараюсь не забыть пройтись с критикой по тем местам библиотеки, которые ещё требуют полировки. Критика и отзывы, как обычно приветствуются. До встречи.</p>
]]></content>
  </entry>
  
</feed>
